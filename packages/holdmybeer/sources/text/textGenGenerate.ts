import { readFileSync } from "node:fs";

interface TextEntry {
  key: string;
  value: string;
  placeholders: string[];
}

/**
 * Generates `text.gen.ts` source from `all.txt`.
 * Expects: catalogPath points to a key=value text catalog file.
 */
export function textGenGenerate(catalogPath: string): string {
  const entries = textGenEntriesParse(readFileSync(catalogPath, "utf-8"));
  const lines: string[] = [
    "/* eslint-disable */",
    "// This file is auto-generated by textGenBuild.ts. Do not edit manually.",
    "",
    "export const text = {"
  ];

  for (const entry of entries) {
    lines.push(`  ${entry.key}: ${JSON.stringify(entry.value)},`);
  }
  lines.push("} as const;");
  lines.push("");
  lines.push("export type TextKey = keyof typeof text;");
  lines.push("");
  lines.push("export type TextValuesByKey = {");
  for (const entry of entries) {
    lines.push(`  ${entry.key}: ${textGenValuesTypeResolve(entry)};`);
  }
  lines.push("};");
  lines.push("");
  lines.push("export type TextValuesForKey<K extends TextKey> = TextValuesByKey[K];");
  lines.push("");
  lines.push("export type TextKeysWithValues = {");
  lines.push("  [K in TextKey]: keyof TextValuesByKey[K] extends never ? never : K;");
  lines.push("}[TextKey];");
  lines.push("");
  lines.push("export type TextKeysWithoutValues = Exclude<TextKey, TextKeysWithValues>;");
  lines.push("");
  return `${lines.join("\n")}\n`;
}

function textGenEntriesParse(raw: string): TextEntry[] {
  const entries: TextEntry[] = [];
  for (const line of raw.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) {
      continue;
    }
    const eq = trimmed.indexOf("=");
    if (eq === -1) {
      continue;
    }
    const key = trimmed.slice(0, eq).trim();
    const value = trimmed.slice(eq + 1).trim();
    entries.push({
      key,
      value,
      placeholders: textGenPlaceholdersParse(value)
    });
  }
  return entries;
}

function textGenPlaceholdersParse(value: string): string[] {
  const result = new Set<string>();
  const pattern = /\{(\w+)\}/g;
  let match: RegExpExecArray | null = pattern.exec(value);
  while (match) {
    result.add(match[1]!);
    match = pattern.exec(value);
  }
  return [...result];
}

function textGenValuesTypeResolve(entry: TextEntry): string {
  if (entry.placeholders.length === 0) {
    return "Record<never, never>";
  }
  return [
    "{",
    ...entry.placeholders.map((placeholder) => `    ${placeholder}: string | number;`),
    "  }"
  ].join("\n");
}
